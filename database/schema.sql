-- Global Models table
create table public.models (
  id bigint generated by default as identity primary key,
  name text not null,
  version text not null,
  weights_url text, -- URL to IPFS or Supabase Storage for current weights
  is_active boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now())
);

-- Enhanced jobs table for Oblivion
create table public.jobs (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  requester_address text not null,
  job_type text not null check (job_type in ('inference', 'training')),
  model_id bigint references public.models(id),
  data_hash text, -- IPFS hash of encrypted data shard
  model_hash text, -- IPFS hash or URL to model/script
  status text default 'pending' check (status in ('pending', 'processing', 'completed', 'failed', 'challenged', 'slashed', 'cancelled', 'expired')),
  result_proof text,
  provider_address text,
  tx_hash text,
  reward numeric default 0,
  script_url text, -- URL to the custom python training script
  dataset_url text, -- URL to the custom dataset shard
  result_url text, -- For weights
  inference_result text,
  input_data text, -- JSON input for inference jobs
  model_url text, -- URL to model weights for inference
  logs_url text, -- URL to worker execution logs
  on_chain_id bigint, -- Reference to blockchain job ID
  expires_at timestamp with time zone -- Job expiration timestamp
);

-- Indexes for performance
create index if not exists idx_jobs_status on public.jobs(status);
create index if not exists idx_jobs_type on public.jobs(job_type);
create index if not exists idx_jobs_requester on public.jobs(requester_address);
create index if not exists idx_jobs_provider on public.jobs(provider_address);
create index if not exists idx_jobs_created on public.jobs(created_at desc);
create index if not exists idx_jobs_on_chain on public.jobs(on_chain_id);

-- Worker Updates (Gradients/Weights) table
create table public.worker_updates (
  id bigint generated by default as identity primary key,
  job_id bigint references public.jobs(id) on delete cascade,
  worker_address text not null,
  update_hash text not null, -- Merkle root of the gradient batch
  update_url text, -- Link to actual gradient data
  created_at timestamp with time zone default timezone('utc'::text, now())
);

-- Indexes for worker_updates
create index if not exists idx_worker_updates_job on public.worker_updates(job_id);
create index if not exists idx_worker_updates_worker on public.worker_updates(worker_address);

-- Nodes table
create table public.nodes (
  id bigint generated by default as identity primary key,
  hardware_id text unique not null,
  last_seen timestamp with time zone default timezone('utc'::text, now()),
  status text default 'active' check (status in ('active', 'offline', 'banned')),
  wallet_address text,
  stake numeric default 0,
  reputation integer default 0
);

-- Indexes for nodes
create index if not exists idx_nodes_wallet on public.nodes(wallet_address);
create index if not exists idx_nodes_status on public.nodes(status);
create index if not exists idx_nodes_last_seen on public.nodes(last_seen desc);

-- Enable RLS
alter table public.models enable row level security;
alter table public.jobs enable row level security;
alter table public.worker_updates enable row level security;
alter table public.nodes enable row level security;

-- ============ RLS Policies ============

-- Models: Read-only for anon, authenticated can insert
create policy "Models: Public read" on public.models 
  for select to anon, authenticated using (true);

create policy "Models: Authenticated insert" on public.models 
  for insert to authenticated with check (true);

-- Jobs: Anyone can read
create policy "Jobs: Public read" on public.jobs 
  for select to anon, authenticated using (true);

-- Jobs: Anyone can insert (create a job)
create policy "Jobs: Public insert" on public.jobs 
  for insert to anon, authenticated with check (true);

-- Jobs: Only requester can update pending jobs (cancel)
-- Or provider can update processing jobs (complete)
create policy "Jobs: Authorized update" on public.jobs 
  for update to anon, authenticated using (
    -- Requester can update their pending jobs
    (status = 'pending' AND requester_address = coalesce(current_setting('request.jwt.claims', true)::json->>'sub', requester_address))
    OR
    -- Provider can update their processing jobs
    (status = 'processing' AND provider_address IS NOT NULL)
    OR
    -- Allow workers to claim pending jobs
    (status = 'pending')
  );

-- Worker Updates: Anyone can read
create policy "Worker Updates: Public read" on public.worker_updates 
  for select to anon, authenticated using (true);

-- Worker Updates: Anyone can insert (workers submit updates)
create policy "Worker Updates: Public insert" on public.worker_updates 
  for insert to anon, authenticated with check (true);

-- Nodes: Anyone can read
create policy "Nodes: Public read" on public.nodes 
  for select to anon, authenticated using (true);

-- Nodes: Anyone can insert/update (node registration/heartbeat)
create policy "Nodes: Public upsert" on public.nodes 
  for insert to anon, authenticated with check (true);

create policy "Nodes: Public update" on public.nodes 
  for update to anon, authenticated using (true);

-- ============ Stored Procedures for Atomic Operations ============

-- Atomic job claim function to prevent race conditions
create or replace function claim_job(
  p_job_id bigint,
  p_provider_address text
) returns boolean as $$
declare
  v_updated boolean;
begin
  -- Atomically update the job if it's still pending
  update public.jobs 
  set 
    status = 'processing',
    provider_address = p_provider_address
  where 
    id = p_job_id 
    and status = 'pending'
    and provider_address is null;
  
  -- Check if the update was successful
  get diagnostics v_updated = row_count;
  return v_updated > 0;
end;
$$ language plpgsql;
